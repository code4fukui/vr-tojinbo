<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>VR東尋坊コースター - VR-Tojinbo-Coaster</title>
<style>
body {
	margin: 0;
}
</style>
</head>
<body>
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
	"imports": {
		"three": "https://code4fukui.github.io/three.js/build/three.module.js",
		"three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
	}
}
</script>

<script type="module">
import * as THREE from 'three';

import {
	RollerCoasterGeometry,
	RollerCoasterShadowGeometry,
	RollerCoasterLiftersGeometry,
	TreesGeometry,
	SkyGeometry
} from 'three/addons/misc/RollerCoaster.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { PromiseGLTFLoader } from "./PromiseGLTFLoader.js";

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType('local');
document.body.appendChild(renderer.domElement);

document.body.appendChild(VRButton.createButton(renderer));

//

const scene = new THREE.Scene();
{ // sky
	scene.background = new THREE.Color(0xf0f0ff); // sky
	const geometry = new THREE.SphereGeometry(200, 60, 40);
	// invert the geometry on the x-axis so that all of the faces point inward
	geometry.scale(-1, 1, 1);
	const texture = new THREE.TextureLoader().load("https://code4fukui.github.io/vr-fukui/img/vr-tojinbo.jpg");
	const material = new THREE.MeshBasicMaterial({ map: texture });
	const mesh = new THREE.Mesh(geometry, material);
	mesh.rotation.y = Math.PI;
	scene.add(mesh);
}
const light = new THREE.HemisphereLight(0xfff0f0, 0x606066);
light.position.set(1, 1, 1);
scene.add(light);

const train = new THREE.Object3D();
scene.add(train);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
train.add(camera);

const loader = new PromiseGLTFLoader();
loader.crossOrigin = "anonymous";
const glb = await loader.promiseLoad("./tojinbo-base1.glb");
const obj = glb.scene;
obj.position.y = 0;

scene.add(glb.scene);

/*
{ // environment
	const geometry = new THREE.PlaneGeometry(500, 500, 15, 15);
	geometry.rotateX(- Math.PI / 2);

	const positions = geometry.attributes.position.array;
	const vertex = new THREE.Vector3();

	for (let i = 0; i < positions.length; i += 3) {
		vertex.fromArray(positions, i);
		vertex.x += Math.random() * 10 - 5;
		vertex.z += Math.random() * 10 - 5;
		const distance = (vertex.distanceTo(scene.position) / 5) - 25;
		vertex.y = Math.random() * Math.max(0, distance);
		vertex.toArray(positions, i);
	}
	geometry.computeVertexNormals();

	const material = new THREE.MeshLambertMaterial({
		color: 0x407000
	});
	const mesh = new THREE.Mesh(geometry, material);
	scene.add(mesh);
	
	{ // trees
		const geometry = new TreesGeometry(mesh);
		const material = new THREE.MeshBasicMaterial({
			side: THREE.DoubleSide, vertexColors: true
		});
		const mesh2 = new THREE.Mesh(geometry, material);
		scene.add(mesh2);
	}
}
*/
/*
{ // sky
	const geometry = new SkyGeometry();
	const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
	const mesh = new THREE.Mesh(geometry, material);
	scene.add(mesh);
}
*/

//

const PI2 = Math.PI * 2;

const curve = (() => {
	const vector = new THREE.Vector3();
	const vector2 = new THREE.Vector3();
	return {
		getPointAt: function(t) {
			t = t * PI2;
			/*
			const x = Math.sin(t * 3) * Math.cos(t * 4) * 50;
			const y = Math.sin(t * 10) * 2 + Math.cos(t * 17) * 2 + 5;
			const z = Math.sin(t) * Math.sin(t * 4) * 50;
			*/
			const x = Math.sin(t * 4) * 20;
			const y = Math.sin(t * 10) * 3 + 16;
			const z = Math.cos(t * 2) * 20;
			return vector.set(x, y, z).multiplyScalar(2);
		},
		getTangentAt: function(t) {
			const delta = 0.0001;
			const t1 = Math.max(0, t - delta);
			const t2 = Math.min(1, t + delta);
			return vector2.copy(this.getPointAt(t2)).sub(this.getPointAt(t1)).normalize();
		}
	};
})();

{
	const geometry = new RollerCoasterGeometry(curve, 1500);
	const material = new THREE.MeshPhongMaterial({
		vertexColors: true
	});
	const mesh = new THREE.Mesh(geometry, material);
	scene.add(mesh);
}
{ // lifter
	const geometry = new RollerCoasterLiftersGeometry(curve, 50);
	const material = new THREE.MeshPhongMaterial();
	const mesh = new THREE.Mesh(geometry, material);
	mesh.position.y = 0.1;
	scene.add(mesh);
}
/*
{ // shadow
	const geometry = new RollerCoasterShadowGeometry(curve, 500);
	const material = new THREE.MeshBasicMaterial({
		color: 0x305000, depthWrite: false, transparent: true
	});
	const mesh = new THREE.Mesh(geometry, material);
	mesh.position.y = 0.1;
	scene.add(mesh);
}
*/

const funfairs = [];

/*
{ // funfairs
	const geometry = new THREE.CylinderGeometry(10, 10, 5, 15);
	const material = new THREE.MeshLambertMaterial({
		color: 0xff8080
	});
	const mesh = new THREE.Mesh(geometry, material);
	mesh.position.set(- 80, 10, - 70);
	mesh.rotation.x = Math.PI / 2;
	scene.add(mesh);
	funfairs.push(mesh);
}
{
	const geometry = new THREE.CylinderGeometry(5, 6, 4, 10);
	const material = new THREE.MeshLambertMaterial({
		color: 0x8080ff
	});
	const mesh = new THREE.Mesh(geometry, material);
	mesh.position.set(50, 2, 30);
	scene.add(mesh);
	funfairs.push(mesh);
}
*/

//

window.addEventListener('resize', onWindowResize);

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

//

const position = new THREE.Vector3();
const tangent = new THREE.Vector3();

const lookAt = new THREE.Vector3();

let velocity = 0;
let progress = 0;

let prevTime = performance.now();

function render() {
	const time = performance.now();
	const delta = time - prevTime;

	// rotate
	for (let i = 0; i < funfairs.length; i++) {
		funfairs[i].rotation.y = time * 0.0004;
	}

	//

	progress += velocity;
	progress = progress % 1;

	position.copy(curve.getPointAt(progress));
	//position.y += 0.3;
	position.y += 0.2;

	train.position.copy(position);

	tangent.copy(curve.getTangentAt(progress));

	velocity -= tangent.y * 0.0000001 * delta;
	velocity = Math.max(0.00004, Math.min(0.0002, velocity));

	train.lookAt(lookAt.copy(position).sub(tangent));

	//
	renderer.render(scene, camera);
	prevTime = time;
}

renderer.setAnimationLoop(render);

</script>

</body>
</html>

