<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>VR東尋坊コースター - VR-Tojinbo-Coaster</title>
<style>
body {
	margin: 0;
}
</style>
</head>
<body>
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
	"imports": {
		"three": "https://code4fukui.github.io/three.js/build/three.module.js",
		"three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
	}
}
</script>

<script type="module">
import * as THREE from "three";
import { Curve, makeCurve, addCoaster } from "./TojinboCoaster.js";
import { VRButton } from "three/addons/webxr/VRButton.js";

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType("local");
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));
window.addEventListener("resize", () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
});

const scene = new THREE.Scene();

//const curve = makeCurve();
//const curve = new Curve();
class MyCurve extends Curve {
  getPointAt(t) {
    t *= Math.PI * 2;
    const x = Math.sin(t * 3) * 30;
    const y = Math.cos(t * 3) * 20 + 40;
    const z = Math.cos(t * 6) * 10;
    return this.vector.set(x, y, z);
  }
}
const curve = new MyCurve();

await addCoaster(scene, curve);

const train = new THREE.Object3D();
scene.add(train);
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
train.add(camera);

const position = new THREE.Vector3();
const tangent = new THREE.Vector3();
const lookAt = new THREE.Vector3();

let velocity = 0;
let progress = 0;

let prevTime = performance.now();
let prevZ = train.rotation.z;
let zz = 0;

renderer.setAnimationLoop(() => {
	const time = performance.now();
	const delta = time - prevTime;

	progress += velocity;
	progress = progress % 1;

	position.copy(curve.getPointAt(progress));
	position.y += 0.2; // 0.3
	train.position.copy(position);
	tangent.copy(curve.getTangentAt(progress));

	velocity -= tangent.y * 0.0000001 * delta;
	velocity = Math.max(0.00004, Math.min(0.0002, velocity));
	//train.lookAt(lookAt.copy(position).sub(tangent));

	/*
	let z = train.rotation.z;
	console.log(z, prevZ, train.rotation)
	//if (Math.abs(z - prevZ) > .1) {
	//if (z > 0 && prevZ < 0) {
	if (prevZ < 0 && z > 0) {
		zz += Math.PI;
		console.log("!!!!", z, prevZ);
	} else if (z < 0 && prevZ > 0) {
		//zz -= Math.PI;
		console.log("!!!!2", z, prevZ);
	} else if (z > 0 && prevZ > 0) {
		//zz -= Math.PI;
	}
	z = train.rotation.z = zz + z;
	prevZ = z;
	*/
		

	const q = train.quaternion;
	const quaternion = new THREE.Quaternion();
	
	const from = new THREE.Vector3();
	from.copy(curve.getPointAt(progress));
	const to = new THREE.Vector3();
	to.copy(curve.getPointAt(progress + 0.001));
	
	//quaternion.setFromUnitVectors(from, to);
	const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.atan(tangent.x));
	const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan(tangent.y));
	const qz = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.atan(tangent.z));
	quaternion.multiply(qz);
	quaternion.multiply(qy);
	quaternion.multiply(qx);

	//quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.atan(tangent.x));
	//quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan(tangent.y));
	//quaternion.setFromAxisAngle(tangent, 0.01);
	//euler.setFromVector3(tangent);
	//quaternion.setFromEuler(euler);
	train.rotation.setFromQuaternion(quaternion);
	/*
	const euler = new THREE.Euler();
	euler.setFromQuaternion(quaternion, "XYZ");
	camera.rotation.x = euler.x;
	camera.rotation.y = euler.y;
	camera.rotation.z = euler.z;
	*/
	
	//camera.rotation.x = Math.PI / 2;
	camera.rotation.y = -Math.PI / 2;
	//train.applyQuaternion(quaternion);
	//train.quaternion.multiply(quaternion);
	
	renderer.render(scene, camera);
	prevTime = time;
});
</script>

</body>
</html>
